data List a <p :: a -> a -> Bool> where
	Nil :: List a <p>
	Cons :: x: a -> xs: List {a | p x _v} <p> -> List a <p>

termination measure len :: List a -> {Int | _v >= 0} where
  Nil -> 0
  Cons x xs -> 1 + len xs

measure elems :: List a -> Set a where
  Nil -> []
  Cons x xs -> [x] + elems xs

reverse |*| (1,0,0) :: xs: List Int -> ys: List Int -> {List Int | len _v == len xs +len ys && (xs == [] && ys == [] ==> _v == []) && (xs == [1] && ys == [] ==> _v == [1]),&& (xs == [1,2] && ys == [] ==> _v == [2,1]) && (xs == [1,2,3] && ys == [] ==> _v == [3,2,1]) && (xs == [1,2,3,4] && ys == [] ==> _v == [4,3,2,1])}


reverse = ??
reverse = match xs with
					Nil -> ys
					Cons x tail -> reverse tail (Cons x ys)

-- synthesize split with specification on size of subproblems
-- size of problem is len xs
-- T(n) = T(n-1) + O(1)
-- EXPECT: reverse (tailOf xs) (Cons x ys)
-- ACTUAL: reverse (tailOf xs) ys

-- smallest split function: s*
-- every 10
